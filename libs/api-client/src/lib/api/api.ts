/* tslint:disable */
/* eslint-disable */
/**
 * API Gateway docs
 * API Gateway for microservices of Blogger microservices.   In order to try out the endpoints in Swagger UI, you can use Api gateway server or choose corresponding server from the dropdown  The gateway is calling to api registry upon the start to retrieve the data of all the registered apis which it uses for creating the proxy -> it compares the apiname which is the path obtained from the docs of each registered api  and if it finds match it makes the call to the corresponding server using the same path.  The data is being cached for 24 hours using redis cache. In case of change, the application is listening on rabbitmq exchange queue specific for communication of api registry and gateway and if it recieves the message about update, it reloads the data directly
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface ActivateUserAccountSchema
 */
export interface ActivateUserAccountSchema {
    /**
     * 
     * @type {string}
     * @memberof ActivateUserAccountSchema
     */
    'avatar': string;
}
/**
 * 
 * @export
 * @interface ApiError
 */
export interface ApiError {
    /**
     * 
     * @type {string}
     * @memberof ApiError
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface ApiMessage
 */
export interface ApiMessage {
    /**
     * 
     * @type {string}
     * @memberof ApiMessage
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface CreateArticleResponse
 */
export interface CreateArticleResponse {
    /**
     * 
     * @type {number}
     * @memberof CreateArticleResponse
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof CreateArticleResponse
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateArticleResponse
     */
    'state'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateArticleResponse
     */
    'image'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateArticleResponse
     */
    'created_at'?: string;
}
/**
 * 
 * @export
 * @interface CreateCommentInput
 */
export interface CreateCommentInput {
    /**
     * 
     * @type {string}
     * @memberof CreateCommentInput
     */
    'author': string;
    /**
     * 
     * @type {string}
     * @memberof CreateCommentInput
     */
    'content': string;
    /**
     * 
     * @type {number}
     * @memberof CreateCommentInput
     */
    'parent_id'?: number;
}
/**
 * 
 * @export
 * @interface CreateCommentResponse
 */
export interface CreateCommentResponse {
    /**
     * 
     * @type {number}
     * @memberof CreateCommentResponse
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreateCommentResponse
     */
    'depth'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreateCommentResponse
     */
    'created_at'?: number;
    /**
     * 
     * @type {string}
     * @memberof CreateCommentResponse
     */
    'author'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateCommentResponse
     */
    'content'?: string;
    /**
     * 
     * @type {number}
     * @memberof CreateCommentResponse
     */
    'parent_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreateCommentResponse
     */
    'article_id'?: number;
}
/**
 * 
 * @export
 * @interface CreateUpdateArticleInput
 */
export interface CreateUpdateArticleInput {
    /**
     * 
     * @type {string}
     * @memberof CreateUpdateArticleInput
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof CreateUpdateArticleInput
     */
    'perex': string;
    /**
     * 
     * @type {string}
     * @memberof CreateUpdateArticleInput
     */
    'content': string;
    /**
     * 
     * @type {string}
     * @memberof CreateUpdateArticleInput
     */
    'image': string;
    /**
     * 
     * @type {string}
     * @memberof CreateUpdateArticleInput
     */
    'state': string;
}
/**
 * 
 * @export
 * @interface CreateUserInput
 */
export interface CreateUserInput {
    /**
     * 
     * @type {string}
     * @memberof CreateUserInput
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserInput
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserInput
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserInput
     */
    'passwordConfirmation': string;
}
/**
 * 
 * @export
 * @interface CreateUserResponse
 */
export interface CreateUserResponse {
    /**
     * 
     * @type {number}
     * @memberof CreateUserResponse
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof CreateUserResponse
     */
    'username'?: string;
}
/**
 * 
 * @export
 * @interface CreateVoteInput
 */
export interface CreateVoteInput {
    /**
     * 
     * @type {boolean}
     * @memberof CreateVoteInput
     */
    'upvote': boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof CreateVoteInput
     */
    'downvote': boolean | null;
}
/**
 * 
 * @export
 * @interface ForgottenPasswordUserSchema
 */
export interface ForgottenPasswordUserSchema {
    /**
     * 
     * @type {string}
     * @memberof ForgottenPasswordUserSchema
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface GetCommentsResponse
 */
export interface GetCommentsResponse {
    /**
     * 
     * @type {number}
     * @memberof GetCommentsResponse
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetCommentsResponse
     */
    'author'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetCommentsResponse
     */
    'content'?: string;
    /**
     * 
     * @type {number}
     * @memberof GetCommentsResponse
     */
    'article_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetCommentsResponse
     */
    'parent_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetCommentsResponse
     */
    'depth'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetCommentsResponse
     */
    'created_at'?: number;
    /**
     * 
     * @type {Array<GetCommentsResponse>}
     * @memberof GetCommentsResponse
     */
    'children'?: Array<GetCommentsResponse>;
}
/**
 * 
 * @export
 * @interface GetUserArticlesResponse
 */
export interface GetUserArticlesResponse {
    /**
     * 
     * @type {number}
     * @memberof GetUserArticlesResponse
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetUserArticlesResponse
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetUserArticlesResponse
     */
    'perex'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetUserArticlesResponse
     */
    'content'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetUserArticlesResponse
     */
    'state'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetUserArticlesResponse
     */
    'image'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetUserArticlesResponse
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetUserArticlesResponse
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetUserArticlesResponse
     */
    'username'?: string;
}
/**
 * 
 * @export
 * @interface LoginUserInput
 */
export interface LoginUserInput {
    /**
     * 
     * @type {string}
     * @memberof LoginUserInput
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof LoginUserInput
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface LoginUserResponse
 */
export interface LoginUserResponse {
    /**
     * 
     * @type {string}
     * @memberof LoginUserResponse
     */
    'token'?: string;
    /**
     * 
     * @type {number}
     * @memberof LoginUserResponse
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof LoginUserResponse
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof LoginUserResponse
     */
    'avatar'?: string;
}
/**
 * 
 * @export
 * @interface ResetPasswordUserSchema
 */
export interface ResetPasswordUserSchema {
    /**
     * 
     * @type {string}
     * @memberof ResetPasswordUserSchema
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof ResetPasswordUserSchema
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof ResetPasswordUserSchema
     */
    'passwordConfirmation': string;
}
/**
 * 
 * @export
 * @interface UpdateArticleResponse
 */
export interface UpdateArticleResponse {
    /**
     * 
     * @type {number}
     * @memberof UpdateArticleResponse
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof UpdateArticleResponse
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateArticleResponse
     */
    'perex'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateArticleResponse
     */
    'content'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateArticleResponse
     */
    'state'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateArticleResponse
     */
    'image'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateArticleResponse
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateArticleResponse
     */
    'updated_at'?: string;
}
/**
 * @type UserServiceApiUsersRecoverPost400Response
 * @export
 */
export type UserServiceApiUsersRecoverPost400Response = ApiError | Array<ValidationError>;

/**
 * 
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'expected'?: string;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'received'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ValidationError
     */
    'path'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface VotesCount
 */
export interface VotesCount {
    /**
     * 
     * @type {number}
     * @memberof VotesCount
     */
    'upvotes'?: number;
    /**
     * 
     * @type {number}
     * @memberof VotesCount
     */
    'downvotes'?: number;
}

/**
 * BloggerServiceApi - axios parameter creator
 * @export
 */
export const BloggerServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete article
         * @param {string} userId 
         * @param {string} articleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bloggerServiceApiBloggersUserIdArticlesArticleIdDelete: async (userId: string, articleId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('bloggerServiceApiBloggersUserIdArticlesArticleIdDelete', 'userId', userId)
            // verify required parameter 'articleId' is not null or undefined
            assertParamExists('bloggerServiceApiBloggersUserIdArticlesArticleIdDelete', 'articleId', articleId)
            const localVarPath = `/blogger-service-api/bloggers/{userId}/articles/{articleId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"articleId"}}`, encodeURIComponent(String(articleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get article for user as admin
         * @param {string} userId 
         * @param {string} articleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bloggerServiceApiBloggersUserIdArticlesArticleIdGet: async (userId: string, articleId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('bloggerServiceApiBloggersUserIdArticlesArticleIdGet', 'userId', userId)
            // verify required parameter 'articleId' is not null or undefined
            assertParamExists('bloggerServiceApiBloggersUserIdArticlesArticleIdGet', 'articleId', articleId)
            const localVarPath = `/blogger-service-api/bloggers/{userId}/articles/{articleId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"articleId"}}`, encodeURIComponent(String(articleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update article
         * @param {string} userId 
         * @param {string} articleId 
         * @param {CreateUpdateArticleInput} createUpdateArticleInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bloggerServiceApiBloggersUserIdArticlesArticleIdPut: async (userId: string, articleId: string, createUpdateArticleInput: CreateUpdateArticleInput, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('bloggerServiceApiBloggersUserIdArticlesArticleIdPut', 'userId', userId)
            // verify required parameter 'articleId' is not null or undefined
            assertParamExists('bloggerServiceApiBloggersUserIdArticlesArticleIdPut', 'articleId', articleId)
            // verify required parameter 'createUpdateArticleInput' is not null or undefined
            assertParamExists('bloggerServiceApiBloggersUserIdArticlesArticleIdPut', 'createUpdateArticleInput', createUpdateArticleInput)
            const localVarPath = `/blogger-service-api/bloggers/{userId}/articles/{articleId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"articleId"}}`, encodeURIComponent(String(articleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createUpdateArticleInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get articles for user as admin
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bloggerServiceApiBloggersUserIdArticlesGet: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('bloggerServiceApiBloggersUserIdArticlesGet', 'userId', userId)
            const localVarPath = `/blogger-service-api/bloggers/{userId}/articles`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Article
         * @param {string} userId 
         * @param {CreateUpdateArticleInput} createUpdateArticleInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bloggerServiceApiBloggersUserIdArticlesPost: async (userId: string, createUpdateArticleInput: CreateUpdateArticleInput, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('bloggerServiceApiBloggersUserIdArticlesPost', 'userId', userId)
            // verify required parameter 'createUpdateArticleInput' is not null or undefined
            assertParamExists('bloggerServiceApiBloggersUserIdArticlesPost', 'createUpdateArticleInput', createUpdateArticleInput)
            const localVarPath = `/blogger-service-api/bloggers/{userId}/articles`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createUpdateArticleInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get one articles by username and article id -> public
         * @param {string} username 
         * @param {string} articleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bloggerServiceApiBlogsUsernameArticlesArticleIdGet: async (username: string, articleId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('bloggerServiceApiBlogsUsernameArticlesArticleIdGet', 'username', username)
            // verify required parameter 'articleId' is not null or undefined
            assertParamExists('bloggerServiceApiBlogsUsernameArticlesArticleIdGet', 'articleId', articleId)
            const localVarPath = `/blogger-service-api/blogs/{username}/articles/{articleId}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)))
                .replace(`{${"articleId"}}`, encodeURIComponent(String(articleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all articles by username -> public
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bloggerServiceApiBlogsUsernameArticlesGet: async (username: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('bloggerServiceApiBlogsUsernameArticlesGet', 'username', username)
            const localVarPath = `/blogger-service-api/blogs/{username}/articles`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get featured articles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bloggerServiceApiFeaturedBlogsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/blogger-service-api/featured-blogs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BloggerServiceApi - functional programming interface
 * @export
 */
export const BloggerServiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BloggerServiceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete article
         * @param {string} userId 
         * @param {string} articleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bloggerServiceApiBloggersUserIdArticlesArticleIdDelete(userId: string, articleId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiMessage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bloggerServiceApiBloggersUserIdArticlesArticleIdDelete(userId, articleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get article for user as admin
         * @param {string} userId 
         * @param {string} articleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bloggerServiceApiBloggersUserIdArticlesArticleIdGet(userId: string, articleId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUserArticlesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bloggerServiceApiBloggersUserIdArticlesArticleIdGet(userId, articleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update article
         * @param {string} userId 
         * @param {string} articleId 
         * @param {CreateUpdateArticleInput} createUpdateArticleInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bloggerServiceApiBloggersUserIdArticlesArticleIdPut(userId: string, articleId: string, createUpdateArticleInput: CreateUpdateArticleInput, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUserArticlesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bloggerServiceApiBloggersUserIdArticlesArticleIdPut(userId, articleId, createUpdateArticleInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get articles for user as admin
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bloggerServiceApiBloggersUserIdArticlesGet(userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetUserArticlesResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bloggerServiceApiBloggersUserIdArticlesGet(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create Article
         * @param {string} userId 
         * @param {CreateUpdateArticleInput} createUpdateArticleInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bloggerServiceApiBloggersUserIdArticlesPost(userId: string, createUpdateArticleInput: CreateUpdateArticleInput, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateArticleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bloggerServiceApiBloggersUserIdArticlesPost(userId, createUpdateArticleInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get one articles by username and article id -> public
         * @param {string} username 
         * @param {string} articleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bloggerServiceApiBlogsUsernameArticlesArticleIdGet(username: string, articleId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUserArticlesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bloggerServiceApiBlogsUsernameArticlesArticleIdGet(username, articleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all articles by username -> public
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bloggerServiceApiBlogsUsernameArticlesGet(username: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetUserArticlesResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bloggerServiceApiBlogsUsernameArticlesGet(username, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get featured articles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bloggerServiceApiFeaturedBlogsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetUserArticlesResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bloggerServiceApiFeaturedBlogsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BloggerServiceApi - factory interface
 * @export
 */
export const BloggerServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BloggerServiceApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete article
         * @param {string} userId 
         * @param {string} articleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bloggerServiceApiBloggersUserIdArticlesArticleIdDelete(userId: string, articleId: string, options?: any): AxiosPromise<ApiMessage> {
            return localVarFp.bloggerServiceApiBloggersUserIdArticlesArticleIdDelete(userId, articleId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get article for user as admin
         * @param {string} userId 
         * @param {string} articleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bloggerServiceApiBloggersUserIdArticlesArticleIdGet(userId: string, articleId: string, options?: any): AxiosPromise<GetUserArticlesResponse> {
            return localVarFp.bloggerServiceApiBloggersUserIdArticlesArticleIdGet(userId, articleId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update article
         * @param {string} userId 
         * @param {string} articleId 
         * @param {CreateUpdateArticleInput} createUpdateArticleInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bloggerServiceApiBloggersUserIdArticlesArticleIdPut(userId: string, articleId: string, createUpdateArticleInput: CreateUpdateArticleInput, options?: any): AxiosPromise<GetUserArticlesResponse> {
            return localVarFp.bloggerServiceApiBloggersUserIdArticlesArticleIdPut(userId, articleId, createUpdateArticleInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get articles for user as admin
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bloggerServiceApiBloggersUserIdArticlesGet(userId: string, options?: any): AxiosPromise<Array<GetUserArticlesResponse>> {
            return localVarFp.bloggerServiceApiBloggersUserIdArticlesGet(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Article
         * @param {string} userId 
         * @param {CreateUpdateArticleInput} createUpdateArticleInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bloggerServiceApiBloggersUserIdArticlesPost(userId: string, createUpdateArticleInput: CreateUpdateArticleInput, options?: any): AxiosPromise<CreateArticleResponse> {
            return localVarFp.bloggerServiceApiBloggersUserIdArticlesPost(userId, createUpdateArticleInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get one articles by username and article id -> public
         * @param {string} username 
         * @param {string} articleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bloggerServiceApiBlogsUsernameArticlesArticleIdGet(username: string, articleId: string, options?: any): AxiosPromise<GetUserArticlesResponse> {
            return localVarFp.bloggerServiceApiBlogsUsernameArticlesArticleIdGet(username, articleId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all articles by username -> public
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bloggerServiceApiBlogsUsernameArticlesGet(username: string, options?: any): AxiosPromise<Array<GetUserArticlesResponse>> {
            return localVarFp.bloggerServiceApiBlogsUsernameArticlesGet(username, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get featured articles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bloggerServiceApiFeaturedBlogsGet(options?: any): AxiosPromise<Array<GetUserArticlesResponse>> {
            return localVarFp.bloggerServiceApiFeaturedBlogsGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BloggerServiceApi - object-oriented interface
 * @export
 * @class BloggerServiceApi
 * @extends {BaseAPI}
 */
export class BloggerServiceApi extends BaseAPI {
    /**
     * 
     * @summary Delete article
     * @param {string} userId 
     * @param {string} articleId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BloggerServiceApi
     */
    public bloggerServiceApiBloggersUserIdArticlesArticleIdDelete(userId: string, articleId: string, options?: AxiosRequestConfig) {
        return BloggerServiceApiFp(this.configuration).bloggerServiceApiBloggersUserIdArticlesArticleIdDelete(userId, articleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get article for user as admin
     * @param {string} userId 
     * @param {string} articleId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BloggerServiceApi
     */
    public bloggerServiceApiBloggersUserIdArticlesArticleIdGet(userId: string, articleId: string, options?: AxiosRequestConfig) {
        return BloggerServiceApiFp(this.configuration).bloggerServiceApiBloggersUserIdArticlesArticleIdGet(userId, articleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update article
     * @param {string} userId 
     * @param {string} articleId 
     * @param {CreateUpdateArticleInput} createUpdateArticleInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BloggerServiceApi
     */
    public bloggerServiceApiBloggersUserIdArticlesArticleIdPut(userId: string, articleId: string, createUpdateArticleInput: CreateUpdateArticleInput, options?: AxiosRequestConfig) {
        return BloggerServiceApiFp(this.configuration).bloggerServiceApiBloggersUserIdArticlesArticleIdPut(userId, articleId, createUpdateArticleInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get articles for user as admin
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BloggerServiceApi
     */
    public bloggerServiceApiBloggersUserIdArticlesGet(userId: string, options?: AxiosRequestConfig) {
        return BloggerServiceApiFp(this.configuration).bloggerServiceApiBloggersUserIdArticlesGet(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Article
     * @param {string} userId 
     * @param {CreateUpdateArticleInput} createUpdateArticleInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BloggerServiceApi
     */
    public bloggerServiceApiBloggersUserIdArticlesPost(userId: string, createUpdateArticleInput: CreateUpdateArticleInput, options?: AxiosRequestConfig) {
        return BloggerServiceApiFp(this.configuration).bloggerServiceApiBloggersUserIdArticlesPost(userId, createUpdateArticleInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get one articles by username and article id -> public
     * @param {string} username 
     * @param {string} articleId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BloggerServiceApi
     */
    public bloggerServiceApiBlogsUsernameArticlesArticleIdGet(username: string, articleId: string, options?: AxiosRequestConfig) {
        return BloggerServiceApiFp(this.configuration).bloggerServiceApiBlogsUsernameArticlesArticleIdGet(username, articleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all articles by username -> public
     * @param {string} username 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BloggerServiceApi
     */
    public bloggerServiceApiBlogsUsernameArticlesGet(username: string, options?: AxiosRequestConfig) {
        return BloggerServiceApiFp(this.configuration).bloggerServiceApiBlogsUsernameArticlesGet(username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get featured articles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BloggerServiceApi
     */
    public bloggerServiceApiFeaturedBlogsGet(options?: AxiosRequestConfig) {
        return BloggerServiceApiFp(this.configuration).bloggerServiceApiFeaturedBlogsGet(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CommentsServiceApi - axios parameter creator
 * @export
 */
export const CommentsServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get comments for article
         * @param {string} articleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commentsServiceApiArticlesArticleIdCommentsGet: async (articleId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'articleId' is not null or undefined
            assertParamExists('commentsServiceApiArticlesArticleIdCommentsGet', 'articleId', articleId)
            const localVarPath = `/comments-service-api/articles/{articleId}/comments`
                .replace(`{${"articleId"}}`, encodeURIComponent(String(articleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Comment for article
         * @param {string} articleId 
         * @param {CreateCommentInput} createCommentInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commentsServiceApiArticlesArticleIdCommentsPost: async (articleId: string, createCommentInput: CreateCommentInput, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'articleId' is not null or undefined
            assertParamExists('commentsServiceApiArticlesArticleIdCommentsPost', 'articleId', articleId)
            // verify required parameter 'createCommentInput' is not null or undefined
            assertParamExists('commentsServiceApiArticlesArticleIdCommentsPost', 'createCommentInput', createCommentInput)
            const localVarPath = `/comments-service-api/articles/{articleId}/comments`
                .replace(`{${"articleId"}}`, encodeURIComponent(String(articleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCommentInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CommentsServiceApi - functional programming interface
 * @export
 */
export const CommentsServiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CommentsServiceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get comments for article
         * @param {string} articleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async commentsServiceApiArticlesArticleIdCommentsGet(articleId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetCommentsResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.commentsServiceApiArticlesArticleIdCommentsGet(articleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create Comment for article
         * @param {string} articleId 
         * @param {CreateCommentInput} createCommentInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async commentsServiceApiArticlesArticleIdCommentsPost(articleId: string, createCommentInput: CreateCommentInput, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateCommentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.commentsServiceApiArticlesArticleIdCommentsPost(articleId, createCommentInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CommentsServiceApi - factory interface
 * @export
 */
export const CommentsServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CommentsServiceApiFp(configuration)
    return {
        /**
         * 
         * @summary Get comments for article
         * @param {string} articleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commentsServiceApiArticlesArticleIdCommentsGet(articleId: string, options?: any): AxiosPromise<Array<GetCommentsResponse>> {
            return localVarFp.commentsServiceApiArticlesArticleIdCommentsGet(articleId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Comment for article
         * @param {string} articleId 
         * @param {CreateCommentInput} createCommentInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commentsServiceApiArticlesArticleIdCommentsPost(articleId: string, createCommentInput: CreateCommentInput, options?: any): AxiosPromise<CreateCommentResponse> {
            return localVarFp.commentsServiceApiArticlesArticleIdCommentsPost(articleId, createCommentInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CommentsServiceApi - object-oriented interface
 * @export
 * @class CommentsServiceApi
 * @extends {BaseAPI}
 */
export class CommentsServiceApi extends BaseAPI {
    /**
     * 
     * @summary Get comments for article
     * @param {string} articleId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommentsServiceApi
     */
    public commentsServiceApiArticlesArticleIdCommentsGet(articleId: string, options?: AxiosRequestConfig) {
        return CommentsServiceApiFp(this.configuration).commentsServiceApiArticlesArticleIdCommentsGet(articleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Comment for article
     * @param {string} articleId 
     * @param {CreateCommentInput} createCommentInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommentsServiceApi
     */
    public commentsServiceApiArticlesArticleIdCommentsPost(articleId: string, createCommentInput: CreateCommentInput, options?: AxiosRequestConfig) {
        return CommentsServiceApiFp(this.configuration).commentsServiceApiArticlesArticleIdCommentsPost(articleId, createCommentInput, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * GraphQLServiceApi - axios parameter creator
 * @export
 */
export const GraphQLServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gateway for bundling article, comments and votes, read only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        graphqlServiceApiGraphqlPost: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/graphql-service-api/graphql`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GraphQLServiceApi - functional programming interface
 * @export
 */
export const GraphQLServiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GraphQLServiceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Gateway for bundling article, comments and votes, read only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async graphqlServiceApiGraphqlPost(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.graphqlServiceApiGraphqlPost(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * GraphQLServiceApi - factory interface
 * @export
 */
export const GraphQLServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GraphQLServiceApiFp(configuration)
    return {
        /**
         * 
         * @summary Gateway for bundling article, comments and votes, read only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        graphqlServiceApiGraphqlPost(options?: any): AxiosPromise<void> {
            return localVarFp.graphqlServiceApiGraphqlPost(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GraphQLServiceApi - object-oriented interface
 * @export
 * @class GraphQLServiceApi
 * @extends {BaseAPI}
 */
export class GraphQLServiceApi extends BaseAPI {
    /**
     * 
     * @summary Gateway for bundling article, comments and votes, read only
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphQLServiceApi
     */
    public graphqlServiceApiGraphqlPost(options?: AxiosRequestConfig) {
        return GraphQLServiceApiFp(this.configuration).graphqlServiceApiGraphqlPost(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserServiceApi - axios parameter creator
 * @export
 */
export const UserServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Activates user account based on query token
         * @param {string} token 
         * @param {ActivateUserAccountSchema} activateUserAccountSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userServiceApiUsersActivatePost: async (token: string, activateUserAccountSchema: ActivateUserAccountSchema, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('userServiceApiUsersActivatePost', 'token', token)
            // verify required parameter 'activateUserAccountSchema' is not null or undefined
            assertParamExists('userServiceApiUsersActivatePost', 'activateUserAccountSchema', activateUserAccountSchema)
            const localVarPath = `/user-service-api/users/activate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(activateUserAccountSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Used for FE application when user is accessing the activation page, the request is sent in order to allow user to access the page
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userServiceApiUsersConfirmIdentifyGet: async (token: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('userServiceApiUsersConfirmIdentifyGet', 'token', token)
            const localVarPath = `/user-service-api/users/confirm-identify`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Sends email with token to reset password
         * @param {ForgottenPasswordUserSchema} forgottenPasswordUserSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userServiceApiUsersForgottenPasswordPost: async (forgottenPasswordUserSchema: ForgottenPasswordUserSchema, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'forgottenPasswordUserSchema' is not null or undefined
            assertParamExists('userServiceApiUsersForgottenPasswordPost', 'forgottenPasswordUserSchema', forgottenPasswordUserSchema)
            const localVarPath = `/user-service-api/users/forgotten-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(forgottenPasswordUserSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Logs in a user
         * @param {LoginUserInput} loginUserInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userServiceApiUsersLoginPost: async (loginUserInput: LoginUserInput, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginUserInput' is not null or undefined
            assertParamExists('userServiceApiUsersLoginPost', 'loginUserInput', loginUserInput)
            const localVarPath = `/user-service-api/users/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginUserInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Register a user
         * @param {CreateUserInput} createUserInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userServiceApiUsersPost: async (createUserInput: CreateUserInput, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createUserInput' is not null or undefined
            assertParamExists('userServiceApiUsersPost', 'createUserInput', createUserInput)
            const localVarPath = `/user-service-api/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createUserInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Changes user\'s password
         * @param {string} token 
         * @param {ResetPasswordUserSchema} resetPasswordUserSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userServiceApiUsersRecoverPost: async (token: string, resetPasswordUserSchema: ResetPasswordUserSchema, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('userServiceApiUsersRecoverPost', 'token', token)
            // verify required parameter 'resetPasswordUserSchema' is not null or undefined
            assertParamExists('userServiceApiUsersRecoverPost', 'resetPasswordUserSchema', resetPasswordUserSchema)
            const localVarPath = `/user-service-api/users/recover`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resetPasswordUserSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Used for FE application when user is accessing the reset password page, the request is sent in order to allow user to access the page
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userServiceApiUsersResetIdentifyGet: async (token: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('userServiceApiUsersResetIdentifyGet', 'token', token)
            const localVarPath = `/user-service-api/users/reset-identify`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserServiceApi - functional programming interface
 * @export
 */
export const UserServiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserServiceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Activates user account based on query token
         * @param {string} token 
         * @param {ActivateUserAccountSchema} activateUserAccountSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userServiceApiUsersActivatePost(token: string, activateUserAccountSchema: ActivateUserAccountSchema, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginUserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userServiceApiUsersActivatePost(token, activateUserAccountSchema, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Used for FE application when user is accessing the activation page, the request is sent in order to allow user to access the page
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userServiceApiUsersConfirmIdentifyGet(token: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiMessage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userServiceApiUsersConfirmIdentifyGet(token, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Sends email with token to reset password
         * @param {ForgottenPasswordUserSchema} forgottenPasswordUserSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userServiceApiUsersForgottenPasswordPost(forgottenPasswordUserSchema: ForgottenPasswordUserSchema, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiMessage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userServiceApiUsersForgottenPasswordPost(forgottenPasswordUserSchema, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Logs in a user
         * @param {LoginUserInput} loginUserInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userServiceApiUsersLoginPost(loginUserInput: LoginUserInput, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginUserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userServiceApiUsersLoginPost(loginUserInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Register a user
         * @param {CreateUserInput} createUserInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userServiceApiUsersPost(createUserInput: CreateUserInput, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateUserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userServiceApiUsersPost(createUserInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Changes user\'s password
         * @param {string} token 
         * @param {ResetPasswordUserSchema} resetPasswordUserSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userServiceApiUsersRecoverPost(token: string, resetPasswordUserSchema: ResetPasswordUserSchema, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiMessage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userServiceApiUsersRecoverPost(token, resetPasswordUserSchema, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Used for FE application when user is accessing the reset password page, the request is sent in order to allow user to access the page
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userServiceApiUsersResetIdentifyGet(token: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiMessage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userServiceApiUsersResetIdentifyGet(token, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserServiceApi - factory interface
 * @export
 */
export const UserServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserServiceApiFp(configuration)
    return {
        /**
         * 
         * @summary Activates user account based on query token
         * @param {string} token 
         * @param {ActivateUserAccountSchema} activateUserAccountSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userServiceApiUsersActivatePost(token: string, activateUserAccountSchema: ActivateUserAccountSchema, options?: any): AxiosPromise<LoginUserResponse> {
            return localVarFp.userServiceApiUsersActivatePost(token, activateUserAccountSchema, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Used for FE application when user is accessing the activation page, the request is sent in order to allow user to access the page
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userServiceApiUsersConfirmIdentifyGet(token: string, options?: any): AxiosPromise<ApiMessage> {
            return localVarFp.userServiceApiUsersConfirmIdentifyGet(token, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Sends email with token to reset password
         * @param {ForgottenPasswordUserSchema} forgottenPasswordUserSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userServiceApiUsersForgottenPasswordPost(forgottenPasswordUserSchema: ForgottenPasswordUserSchema, options?: any): AxiosPromise<ApiMessage> {
            return localVarFp.userServiceApiUsersForgottenPasswordPost(forgottenPasswordUserSchema, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Logs in a user
         * @param {LoginUserInput} loginUserInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userServiceApiUsersLoginPost(loginUserInput: LoginUserInput, options?: any): AxiosPromise<LoginUserResponse> {
            return localVarFp.userServiceApiUsersLoginPost(loginUserInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Register a user
         * @param {CreateUserInput} createUserInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userServiceApiUsersPost(createUserInput: CreateUserInput, options?: any): AxiosPromise<CreateUserResponse> {
            return localVarFp.userServiceApiUsersPost(createUserInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Changes user\'s password
         * @param {string} token 
         * @param {ResetPasswordUserSchema} resetPasswordUserSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userServiceApiUsersRecoverPost(token: string, resetPasswordUserSchema: ResetPasswordUserSchema, options?: any): AxiosPromise<ApiMessage> {
            return localVarFp.userServiceApiUsersRecoverPost(token, resetPasswordUserSchema, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Used for FE application when user is accessing the reset password page, the request is sent in order to allow user to access the page
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userServiceApiUsersResetIdentifyGet(token: string, options?: any): AxiosPromise<ApiMessage> {
            return localVarFp.userServiceApiUsersResetIdentifyGet(token, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserServiceApi - object-oriented interface
 * @export
 * @class UserServiceApi
 * @extends {BaseAPI}
 */
export class UserServiceApi extends BaseAPI {
    /**
     * 
     * @summary Activates user account based on query token
     * @param {string} token 
     * @param {ActivateUserAccountSchema} activateUserAccountSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserServiceApi
     */
    public userServiceApiUsersActivatePost(token: string, activateUserAccountSchema: ActivateUserAccountSchema, options?: AxiosRequestConfig) {
        return UserServiceApiFp(this.configuration).userServiceApiUsersActivatePost(token, activateUserAccountSchema, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Used for FE application when user is accessing the activation page, the request is sent in order to allow user to access the page
     * @param {string} token 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserServiceApi
     */
    public userServiceApiUsersConfirmIdentifyGet(token: string, options?: AxiosRequestConfig) {
        return UserServiceApiFp(this.configuration).userServiceApiUsersConfirmIdentifyGet(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Sends email with token to reset password
     * @param {ForgottenPasswordUserSchema} forgottenPasswordUserSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserServiceApi
     */
    public userServiceApiUsersForgottenPasswordPost(forgottenPasswordUserSchema: ForgottenPasswordUserSchema, options?: AxiosRequestConfig) {
        return UserServiceApiFp(this.configuration).userServiceApiUsersForgottenPasswordPost(forgottenPasswordUserSchema, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Logs in a user
     * @param {LoginUserInput} loginUserInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserServiceApi
     */
    public userServiceApiUsersLoginPost(loginUserInput: LoginUserInput, options?: AxiosRequestConfig) {
        return UserServiceApiFp(this.configuration).userServiceApiUsersLoginPost(loginUserInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Register a user
     * @param {CreateUserInput} createUserInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserServiceApi
     */
    public userServiceApiUsersPost(createUserInput: CreateUserInput, options?: AxiosRequestConfig) {
        return UserServiceApiFp(this.configuration).userServiceApiUsersPost(createUserInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Changes user\'s password
     * @param {string} token 
     * @param {ResetPasswordUserSchema} resetPasswordUserSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserServiceApi
     */
    public userServiceApiUsersRecoverPost(token: string, resetPasswordUserSchema: ResetPasswordUserSchema, options?: AxiosRequestConfig) {
        return UserServiceApiFp(this.configuration).userServiceApiUsersRecoverPost(token, resetPasswordUserSchema, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Used for FE application when user is accessing the reset password page, the request is sent in order to allow user to access the page
     * @param {string} token 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserServiceApi
     */
    public userServiceApiUsersResetIdentifyGet(token: string, options?: AxiosRequestConfig) {
        return UserServiceApiFp(this.configuration).userServiceApiUsersResetIdentifyGet(token, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * VotesServiceApi - axios parameter creator
 * @export
 */
export const VotesServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Vote count for comment
         * @param {string} articleId 
         * @param {string} commentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        votesServiceApiArticlesArticleIdCommentsCommentIdVotesGet: async (articleId: string, commentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'articleId' is not null or undefined
            assertParamExists('votesServiceApiArticlesArticleIdCommentsCommentIdVotesGet', 'articleId', articleId)
            // verify required parameter 'commentId' is not null or undefined
            assertParamExists('votesServiceApiArticlesArticleIdCommentsCommentIdVotesGet', 'commentId', commentId)
            const localVarPath = `/votes-service-api/articles/{articleId}/comments/{commentId}/votes`
                .replace(`{${"articleId"}}`, encodeURIComponent(String(articleId)))
                .replace(`{${"commentId"}}`, encodeURIComponent(String(commentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Vote for comment
         * @param {string} articleId 
         * @param {string} commentId 
         * @param {CreateVoteInput} createVoteInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        votesServiceApiArticlesArticleIdCommentsCommentIdVotesPost: async (articleId: string, commentId: string, createVoteInput: CreateVoteInput, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'articleId' is not null or undefined
            assertParamExists('votesServiceApiArticlesArticleIdCommentsCommentIdVotesPost', 'articleId', articleId)
            // verify required parameter 'commentId' is not null or undefined
            assertParamExists('votesServiceApiArticlesArticleIdCommentsCommentIdVotesPost', 'commentId', commentId)
            // verify required parameter 'createVoteInput' is not null or undefined
            assertParamExists('votesServiceApiArticlesArticleIdCommentsCommentIdVotesPost', 'createVoteInput', createVoteInput)
            const localVarPath = `/votes-service-api/articles/{articleId}/comments/{commentId}/votes`
                .replace(`{${"articleId"}}`, encodeURIComponent(String(articleId)))
                .replace(`{${"commentId"}}`, encodeURIComponent(String(commentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createVoteInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get All Vote count for article id
         * @param {string} articleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        votesServiceApiArticlesArticleIdCommentsVotesGet: async (articleId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'articleId' is not null or undefined
            assertParamExists('votesServiceApiArticlesArticleIdCommentsVotesGet', 'articleId', articleId)
            const localVarPath = `/votes-service-api/articles/{articleId}/comments-votes`
                .replace(`{${"articleId"}}`, encodeURIComponent(String(articleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VotesServiceApi - functional programming interface
 * @export
 */
export const VotesServiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VotesServiceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get Vote count for comment
         * @param {string} articleId 
         * @param {string} commentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async votesServiceApiArticlesArticleIdCommentsCommentIdVotesGet(articleId: string, commentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VotesCount>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.votesServiceApiArticlesArticleIdCommentsCommentIdVotesGet(articleId, commentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create Vote for comment
         * @param {string} articleId 
         * @param {string} commentId 
         * @param {CreateVoteInput} createVoteInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async votesServiceApiArticlesArticleIdCommentsCommentIdVotesPost(articleId: string, commentId: string, createVoteInput: CreateVoteInput, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiMessage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.votesServiceApiArticlesArticleIdCommentsCommentIdVotesPost(articleId, commentId, createVoteInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get All Vote count for article id
         * @param {string} articleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async votesServiceApiArticlesArticleIdCommentsVotesGet(articleId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VotesCount>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.votesServiceApiArticlesArticleIdCommentsVotesGet(articleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * VotesServiceApi - factory interface
 * @export
 */
export const VotesServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VotesServiceApiFp(configuration)
    return {
        /**
         * 
         * @summary Get Vote count for comment
         * @param {string} articleId 
         * @param {string} commentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        votesServiceApiArticlesArticleIdCommentsCommentIdVotesGet(articleId: string, commentId: string, options?: any): AxiosPromise<Array<VotesCount>> {
            return localVarFp.votesServiceApiArticlesArticleIdCommentsCommentIdVotesGet(articleId, commentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Vote for comment
         * @param {string} articleId 
         * @param {string} commentId 
         * @param {CreateVoteInput} createVoteInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        votesServiceApiArticlesArticleIdCommentsCommentIdVotesPost(articleId: string, commentId: string, createVoteInput: CreateVoteInput, options?: any): AxiosPromise<ApiMessage> {
            return localVarFp.votesServiceApiArticlesArticleIdCommentsCommentIdVotesPost(articleId, commentId, createVoteInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get All Vote count for article id
         * @param {string} articleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        votesServiceApiArticlesArticleIdCommentsVotesGet(articleId: string, options?: any): AxiosPromise<Array<VotesCount>> {
            return localVarFp.votesServiceApiArticlesArticleIdCommentsVotesGet(articleId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VotesServiceApi - object-oriented interface
 * @export
 * @class VotesServiceApi
 * @extends {BaseAPI}
 */
export class VotesServiceApi extends BaseAPI {
    /**
     * 
     * @summary Get Vote count for comment
     * @param {string} articleId 
     * @param {string} commentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VotesServiceApi
     */
    public votesServiceApiArticlesArticleIdCommentsCommentIdVotesGet(articleId: string, commentId: string, options?: AxiosRequestConfig) {
        return VotesServiceApiFp(this.configuration).votesServiceApiArticlesArticleIdCommentsCommentIdVotesGet(articleId, commentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Vote for comment
     * @param {string} articleId 
     * @param {string} commentId 
     * @param {CreateVoteInput} createVoteInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VotesServiceApi
     */
    public votesServiceApiArticlesArticleIdCommentsCommentIdVotesPost(articleId: string, commentId: string, createVoteInput: CreateVoteInput, options?: AxiosRequestConfig) {
        return VotesServiceApiFp(this.configuration).votesServiceApiArticlesArticleIdCommentsCommentIdVotesPost(articleId, commentId, createVoteInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get All Vote count for article id
     * @param {string} articleId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VotesServiceApi
     */
    public votesServiceApiArticlesArticleIdCommentsVotesGet(articleId: string, options?: AxiosRequestConfig) {
        return VotesServiceApiFp(this.configuration).votesServiceApiArticlesArticleIdCommentsVotesGet(articleId, options).then((request) => request(this.axios, this.basePath));
    }
}


